/*
   This file was generated automatically by Alchitry Labs version 1.2.1.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module regfile_10 (
    input clk,
    input [2:0] read_address_1,
    input [2:0] read_address_2,
    input [2:0] write_address,
    input [9:0] write_data,
    input write_enable,
    input rst,
    output reg [9:0] read_data_1,
    output reg [9:0] read_data_2,
    input [0:0] score_in,
    input [9:0] score,
    output reg [9:0] pointer_out,
    output reg [9:0] row_red_out,
    output reg [9:0] row_green_out,
    output reg [9:0] row_blue_out,
    output reg [9:0] rand_register_out,
    output reg [9:0] current_timer_out,
    output reg [9:0] current_score_out,
    output reg [9:0] ra_out,
    output reg [9:0] rb_out
  );
  
  
  
  reg [9:0] out_a;
  reg [9:0] out_b;
  
  reg [9:0] M_row_red_d, M_row_red_q = 1'h0;
  reg [9:0] M_row_green_d, M_row_green_q = 1'h0;
  reg [9:0] M_row_blue_d, M_row_blue_q = 1'h0;
  reg [9:0] M_current_score_d, M_current_score_q = 1'h0;
  reg [9:0] M_pointer_d, M_pointer_q = 1'h0;
  reg [9:0] M_rand_register_d, M_rand_register_q = 1'h0;
  reg [9:0] M_temp_var_d, M_temp_var_q = 1'h0;
  reg [9:0] M_current_timer_d, M_current_timer_q = 1'h0;
  
  always @* begin
    M_row_green_d = M_row_green_q;
    M_pointer_d = M_pointer_q;
    M_rand_register_d = M_rand_register_q;
    M_current_timer_d = M_current_timer_q;
    M_row_red_d = M_row_red_q;
    M_current_score_d = M_current_score_q;
    M_temp_var_d = M_temp_var_q;
    M_row_blue_d = M_row_blue_q;
    
    out_a = 1'h0;
    out_b = 1'h0;
    if (score_in) begin
      M_current_score_d = M_current_score_q + score;
    end
    if (write_enable) begin
      
      case (write_address)
        3'h0: begin
          M_row_red_d = write_data;
        end
        3'h1: begin
          M_row_green_d = write_data;
        end
        3'h2: begin
          M_row_blue_d = write_data;
        end
        3'h3: begin
          M_current_score_d = write_data;
        end
        3'h4: begin
          M_pointer_d = write_data;
        end
        3'h5: begin
          M_rand_register_d = write_data;
        end
        3'h6: begin
          M_current_timer_d = write_data;
        end
        3'h7: begin
          M_temp_var_d = write_data;
        end
      endcase
    end
    
    case (read_address_1)
      3'h0: begin
        read_data_1 = M_row_red_q;
        out_a = M_row_red_q;
      end
      3'h1: begin
        read_data_1 = M_row_green_q;
        out_a = M_row_green_q;
      end
      3'h2: begin
        read_data_1 = M_row_blue_q;
        out_a = M_row_blue_q;
      end
      3'h3: begin
        read_data_1 = M_current_score_q;
        out_a = M_current_score_q;
      end
      3'h4: begin
        read_data_1 = M_pointer_q;
        out_a = M_pointer_q;
      end
      3'h5: begin
        read_data_1 = M_rand_register_q;
        out_a = M_rand_register_q;
      end
      3'h6: begin
        read_data_1 = M_current_timer_q;
        out_a = M_current_timer_q;
      end
      3'h7: begin
        read_data_1 = M_temp_var_q;
        out_a = M_temp_var_q;
      end
      default: begin
        read_data_1 = 10'h000;
      end
    endcase
    
    case (read_address_2)
      3'h0: begin
        read_data_2 = M_row_red_q;
        out_b = M_row_red_q;
      end
      3'h1: begin
        read_data_2 = M_row_green_q;
        out_b = M_row_green_q;
      end
      3'h2: begin
        read_data_2 = M_row_blue_q;
        out_b = M_row_blue_q;
      end
      3'h3: begin
        read_data_2 = M_current_score_q;
        out_b = M_current_score_q;
      end
      3'h4: begin
        read_data_2 = M_pointer_q;
        out_b = M_pointer_q;
      end
      3'h5: begin
        read_data_2 = M_rand_register_q;
        out_b = M_rand_register_q;
      end
      3'h6: begin
        read_data_2 = M_current_timer_q;
        out_b = M_current_timer_q;
      end
      3'h7: begin
        read_data_2 = M_temp_var_q;
        out_b = M_temp_var_q;
      end
      default: begin
        read_data_2 = 10'h000;
      end
    endcase
    ra_out = out_a;
    rb_out = out_b;
    row_red_out = M_row_red_q;
    row_green_out = M_row_green_q;
    row_blue_out = M_row_blue_q;
    pointer_out = M_pointer_q;
    rand_register_out = M_rand_register_q;
    current_timer_out = M_current_timer_q;
    current_score_out = M_current_score_q;
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_row_red_q <= 1'h0;
      M_row_green_q <= 1'h0;
      M_row_blue_q <= 1'h0;
      M_current_score_q <= 1'h0;
      M_pointer_q <= 1'h0;
      M_rand_register_q <= 1'h0;
      M_temp_var_q <= 1'h0;
      M_current_timer_q <= 1'h0;
    end else begin
      M_row_red_q <= M_row_red_d;
      M_row_green_q <= M_row_green_d;
      M_row_blue_q <= M_row_blue_d;
      M_current_score_q <= M_current_score_d;
      M_pointer_q <= M_pointer_d;
      M_rand_register_q <= M_rand_register_d;
      M_temp_var_q <= M_temp_var_d;
      M_current_timer_q <= M_current_timer_d;
    end
  end
  
endmodule
